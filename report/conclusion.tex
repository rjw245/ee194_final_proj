\section{Conclusion}\label{sec::conclusion}
With this work, we have demonstrated Rust's usefulness in helping the programmer write safe concurrent code. We have shown that Rust for the most part achieves the same speedup as C Pthreads when adding additional threads. This breaks down in Sniper, however, when the number of parallel lines of execution exceeds the number of system threads. It is unclear why the Sniper scheduler elects to switch out the main thread in C and not in Rust even though from the code it would appear both simply wait for spawned threads to join.
This is definitely an issue that would be worth bringing up to either the Rust language designers and the Sniper developers as it hampers the functionality of Sniper in profiling concurrent Rust performance.
    
    Aside from speed up comparisons, we also observed that Rust is still generally inferior to C when it comes to absolute execution time performance. In addition to being slower than C overall, we uncovered certain "gotchas" in Rust where using a \texttt{Mutex<T>} can effectively render all concurrency useless due to locking.
    
    Overall, we believe that Rust has the potential to become a useful parallel programming language. Its ownership system and concurrency rules and constructs offer powerful compile-time restrictions that help programmers write safe and efficient concurrent programs. Although new, Rust is already being used in major projects such as Servo, an Internet browser developed by Mozilla. As the number of cores on chip continues to grow, languages like Rust will help programmers take advantage of these resources by making concurrent programming safer and easier.