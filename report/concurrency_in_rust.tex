\section{Concurrency in Rust}\label{sec::rust_concurrency}
Rust's guarantees memory safety, efficient C bindings, and data-race free threading at compile time. Multithreading in Rust is available through its standard library. Threads are spawned using a thin wrapper around Pthreads. Syntactically, threads in Rust execute a closure. A handle is returned when a thread is spawned, similar to a \texttt{pthread\_t} in C.

In order to help programmers write and reason about concurrent code, Rust offers a static type system with the concept of traits. Traits tell the Rust compiler about the functionality that a type must provide, and there are two key traits that matter for concurrent programming. The first is \texttt{Send}. \texttt{Send}-compliant types can have their ownership safely transferred between threads; types that do not implement \texttt{Send} are not guaranteed to be thread-safe and will not be allowed to be sent from one thread to another. The second property is \texttt{Sync}, which guarantees that concurrent accesses from multiple threads to the same data structure are safe. In other words, the threads' access to the \texttt{Sync} data is mutually exclusive. As an example, Rust implements mutexes using the \texttt{Sync} property.

Often, multithreading in C involves passing pointers to the same data to different threads, creating a potential data race depending on the threads' access pattern. Rust's type system prevents threads from directly sharing references to the same memory. Instead, Rust mandates that such sharing be managed by the \texttt{Arc<T>} type, an atomic reference count type. \texttt{Arc}s keep track of how many threads have access to the data they contain so that they know when the data falls out of scope and can be deallocated. For \texttt{Arc<T>} to be passed to threads, it and its contents must implement \texttt{Send} and \texttt{Sync}. For immutable values, both characteristics are guaranteed. However, the \texttt{Sync} property is not inherently implemented by mutable values because a data race is possible. Consequently, mutable values must first be stored within a \texttt{Mutex<T>} , which only allows one thread to hold the lock to access its reference.

The \texttt{Mutex<T>} type is similar to \texttt{pthread\_mutex\_t}, but it differs in that it wraps the data which it protects unlike the \texttt{pthread\_mutex\_t} which wraps sections of code. This echos Rust's design philosophy to ``lock data, not code''~\cite{rust-lang}. The idea is that linking the mutex to the data it protects limits misuse and deadlock. From the programmer's perspective, there are similarities between the usage of \texttt{std::thread}s in Rust and Pthreads in C, but Rust's enforcement of ownership with mutable state, and type system ensure that threaded processes will be memory safe and free of race conditions.