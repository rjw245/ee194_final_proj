%%% Setup %%%
\documentclass{article} \usepackage{fullpage} \usepackage{url} \title{Proposal:
A Comparison of Concurrency in Rust and C} \author{ Josh Pfosi\\ \and Riley
Wood\\ \and Henry Zhou\\ } \begin{document} \maketitle

%%% The Meat %%%

\section*{Background}

Computer architects today are faced with a power wall. CPU clock speeds cannot
increase any further, or else they will be unable to be cooled. Yet the number
of transistors onchip continues to double every two years as predicted by
Moore's Law, so the question to architects is this: what can we spend additional
transistors on, if not clock speed? The industry has answered this question by
converging on multicore computers: computers that integrate multiple processor
cores into one chip~\cite{Larus:2009}. The industry is forced to favor increased
parallelism over increased speed.

This shift has huge ramifications for programmers. A program's performance
improves automatically as clock speed increases, but programs need to be written
specially to take advantage of hardware parallelism. As of now, multicore
machines put the burden of utilizing parallel cores on the programmer, and
writing parallel programs is difficult. It is hard for most people to decompose
a program into parallel workloads and think about all of the interactions that
can occur as they are executing at once. This makes the new types of errors that
arise with concurrency that much harder to anticipate, find, and prevent. These
include deadlock, livelock, and data races. It's important that programmers
start writing parallel programs in order to take advantage of all that Moore's
Law offers, but for this to happen, programmers need to feel confident in their
ability to write safe, parallel code.

Rust is a new systems programming language that facilitates writing safe
concurrent programs through an advanced type system~\cite{rust-lang.org}. It
introduces the idea of data ownership where variable bindings "own" the data to
which they point. This and other statically enforced safety features reduce the
burden of concurrent programming on the programmer. Contrast this with C which
primarily relies on lock-based synchronization, a greater degree of programmer
expertise, and often project-specific conventions. This creates pitfalls for
programmers and proliferates common and often subtle concurrency bugs. An
unresolved question, however, is whether Rust's strict compile-time rules and
"extra runtime bookeeping" have an adverse effect on
performance~\cite{rust-lang.org}.


\section*{Goal and Description}

Rust's concurrency constructs and paradigms make writing concurrent code safer
and easier by preventing code with concurrency errors from compiling. We are
interested to see if Rust's new constructs affect its performance in a
significantly detrimental way when compared with C, a widely-used
concurrency-capable languages. Metrics we are interested in include program
execution time, power consumption, and idle time. We will present our findings
through a presentation and written report.

 

%Add why our findings will be useful to others

\section*{Methodology}

Rust and C are inherently different in many ways, so we will need to isolate how
each one's implementation of concurrency impact performance. We will do this in
the following way:

We will choose a set of benchmarks that can be run both serially and
parallelized and implement them in C and Rust. We will compare the performance
of the two languages on the single-threaded benchmarks to establish a baseline
for how Rust and C differ. Then any further differences that arise in our
multi-threaded tests can safely be attributed to each language's implementation
of concurrency.  Our benchmarks will be run in a multicore simulator. We will
vary parameters such as input size and the number of threads running and collect
data on metrics such as total execution time, CPU idle time, and power
consumption.  

Furthermore, we plan on exploring the differences in performance observed using
different hardware. For this section, we will execute concurrent benchmarks at
different thread counts with different hardware settings such as L1/L2 cache
size and cache associativity. We seek to examine if changes in relative
performance between C and Rust arise when running benchmarks on different
hardware. 


\section*{Equipment and Tools}

We will be writing code in C and Rust. For more convincing analysis, we will
compile our C code using both clang and gcc. Rust will be compiled with the
standard rustc compiler. We are still in the process of selecting a suite of
concurrent benchmarks to use. Once we have chosen a set of benchmarks and ported
them to Rust, we will run our simulations in the SNIPER Multi-Core Simulator
\cite{Sniper} on the Linux compute servers hosted at Tufts University.

%benchmark ideas: matrix multiplication Josh's Senior Design benchmark parsec 

\section*{Timeline}

April 15: Completed creation of benchmarks in C and Rust and setup of testing
environment.  \\\\ April 20: Project status discussion with Dr. Hempstead \\\\
April 22: Completed all benchmarks and collect all data \\\\ April 27: Project
Oral Presentation \\\\ May 3:  Final Report Submission


%%% References %%%
\bibliographystyle{unsrt} \bibliography{proposal}

%%% The End %%%
\end{document}
